// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'button_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ButtonStateTearOff {
  const _$ButtonStateTearOff();

  Idling idling() {
    return const Idling();
  }

  Loading loading() {
    return const Loading();
  }

  Completing completing() {
    return const Completing();
  }

  Erroring erroring() {
    return const Erroring();
  }
}

/// @nodoc
const $ButtonState = _$ButtonStateTearOff();

/// @nodoc
mixin _$ButtonState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idling,
    required TResult Function() loading,
    required TResult Function() completing,
    required TResult Function() erroring,
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idling,
    TResult Function()? loading,
    TResult Function()? completing,
    TResult Function()? erroring,
    required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idling value) idling,
    required TResult Function(Loading value) loading,
    required TResult Function(Completing value) completing,
    required TResult Function(Erroring value) erroring,
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idling value)? idling,
    TResult Function(Loading value)? loading,
    TResult Function(Completing value)? completing,
    TResult Function(Erroring value)? erroring,
    required TResult orElse(),
  });
}

/// @nodoc
abstract class $ButtonStateCopyWith<$Res> {
  factory $ButtonStateCopyWith(
          ButtonState value, $Res Function(ButtonState) then) =
      _$ButtonStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ButtonStateCopyWithImpl<$Res> implements $ButtonStateCopyWith<$Res> {
  _$ButtonStateCopyWithImpl(this._value, this._then);

  final ButtonState _value;
  // ignore: unused_field
  final $Res Function(ButtonState) _then;
}

/// @nodoc
abstract class $IdlingCopyWith<$Res> {
  factory $IdlingCopyWith(Idling value, $Res Function(Idling) then) =
      _$IdlingCopyWithImpl<$Res>;
}

/// @nodoc
class _$IdlingCopyWithImpl<$Res> extends _$ButtonStateCopyWithImpl<$Res>
    implements $IdlingCopyWith<$Res> {
  _$IdlingCopyWithImpl(Idling _value, $Res Function(Idling) _then)
      : super(_value, (v) => _then(v as Idling));

  @override
  Idling get _value => super._value as Idling;
}

/// @nodoc
class _$Idling implements Idling {
  const _$Idling();

  @override
  String toString() {
    return 'ButtonState.idling()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Idling);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idling,
    required TResult Function() loading,
    required TResult Function() completing,
    required TResult Function() erroring,
  }) {
    return idling();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idling,
    TResult Function()? loading,
    TResult Function()? completing,
    TResult Function()? erroring,
    required TResult orElse(),
  }) {
    if (idling != null) {
      return idling();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idling value) idling,
    required TResult Function(Loading value) loading,
    required TResult Function(Completing value) completing,
    required TResult Function(Erroring value) erroring,
  }) {
    return idling(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idling value)? idling,
    TResult Function(Loading value)? loading,
    TResult Function(Completing value)? completing,
    TResult Function(Erroring value)? erroring,
    required TResult orElse(),
  }) {
    if (idling != null) {
      return idling(this);
    }
    return orElse();
  }
}

abstract class Idling implements ButtonState {
  const factory Idling() = _$Idling;
}

/// @nodoc
abstract class $LoadingCopyWith<$Res> {
  factory $LoadingCopyWith(Loading value, $Res Function(Loading) then) =
      _$LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoadingCopyWithImpl<$Res> extends _$ButtonStateCopyWithImpl<$Res>
    implements $LoadingCopyWith<$Res> {
  _$LoadingCopyWithImpl(Loading _value, $Res Function(Loading) _then)
      : super(_value, (v) => _then(v as Loading));

  @override
  Loading get _value => super._value as Loading;
}

/// @nodoc
class _$Loading implements Loading {
  const _$Loading();

  @override
  String toString() {
    return 'ButtonState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idling,
    required TResult Function() loading,
    required TResult Function() completing,
    required TResult Function() erroring,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idling,
    TResult Function()? loading,
    TResult Function()? completing,
    TResult Function()? erroring,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idling value) idling,
    required TResult Function(Loading value) loading,
    required TResult Function(Completing value) completing,
    required TResult Function(Erroring value) erroring,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idling value)? idling,
    TResult Function(Loading value)? loading,
    TResult Function(Completing value)? completing,
    TResult Function(Erroring value)? erroring,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class Loading implements ButtonState {
  const factory Loading() = _$Loading;
}

/// @nodoc
abstract class $CompletingCopyWith<$Res> {
  factory $CompletingCopyWith(
          Completing value, $Res Function(Completing) then) =
      _$CompletingCopyWithImpl<$Res>;
}

/// @nodoc
class _$CompletingCopyWithImpl<$Res> extends _$ButtonStateCopyWithImpl<$Res>
    implements $CompletingCopyWith<$Res> {
  _$CompletingCopyWithImpl(Completing _value, $Res Function(Completing) _then)
      : super(_value, (v) => _then(v as Completing));

  @override
  Completing get _value => super._value as Completing;
}

/// @nodoc
class _$Completing implements Completing {
  const _$Completing();

  @override
  String toString() {
    return 'ButtonState.completing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Completing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idling,
    required TResult Function() loading,
    required TResult Function() completing,
    required TResult Function() erroring,
  }) {
    return completing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idling,
    TResult Function()? loading,
    TResult Function()? completing,
    TResult Function()? erroring,
    required TResult orElse(),
  }) {
    if (completing != null) {
      return completing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idling value) idling,
    required TResult Function(Loading value) loading,
    required TResult Function(Completing value) completing,
    required TResult Function(Erroring value) erroring,
  }) {
    return completing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idling value)? idling,
    TResult Function(Loading value)? loading,
    TResult Function(Completing value)? completing,
    TResult Function(Erroring value)? erroring,
    required TResult orElse(),
  }) {
    if (completing != null) {
      return completing(this);
    }
    return orElse();
  }
}

abstract class Completing implements ButtonState {
  const factory Completing() = _$Completing;
}

/// @nodoc
abstract class $ErroringCopyWith<$Res> {
  factory $ErroringCopyWith(Erroring value, $Res Function(Erroring) then) =
      _$ErroringCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErroringCopyWithImpl<$Res> extends _$ButtonStateCopyWithImpl<$Res>
    implements $ErroringCopyWith<$Res> {
  _$ErroringCopyWithImpl(Erroring _value, $Res Function(Erroring) _then)
      : super(_value, (v) => _then(v as Erroring));

  @override
  Erroring get _value => super._value as Erroring;
}

/// @nodoc
class _$Erroring implements Erroring {
  const _$Erroring();

  @override
  String toString() {
    return 'ButtonState.erroring()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Erroring);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idling,
    required TResult Function() loading,
    required TResult Function() completing,
    required TResult Function() erroring,
  }) {
    return erroring();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idling,
    TResult Function()? loading,
    TResult Function()? completing,
    TResult Function()? erroring,
    required TResult orElse(),
  }) {
    if (erroring != null) {
      return erroring();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idling value) idling,
    required TResult Function(Loading value) loading,
    required TResult Function(Completing value) completing,
    required TResult Function(Erroring value) erroring,
  }) {
    return erroring(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idling value)? idling,
    TResult Function(Loading value)? loading,
    TResult Function(Completing value)? completing,
    TResult Function(Erroring value)? erroring,
    required TResult orElse(),
  }) {
    if (erroring != null) {
      return erroring(this);
    }
    return orElse();
  }
}

abstract class Erroring implements ButtonState {
  const factory Erroring() = _$Erroring;
}
